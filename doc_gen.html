
<html>
    <head>
        <script src="https://google-code-prettify.googlecode.com/svn/loader/run_prettify.js"></script>
        <script src="http://code.jquery.com/jquery-1.9.1.min.js"></script>
        <style>
            body .script {
                width: 100%;
                word-wrap:break-word;
                display:none;
            }
            .func {
                margin: 15px;
                background-color: #ccc;
                padding: 5px;
            }
            .todo {
                background-color: yellow;
            }
            .internal {
                background-color: red;
            }
            body, html {
                font-family: 'Helvetica';
            }
        </style>
    </head>
    <body>
        <h1>Web-Sync Client API</h1>
            <h3>File: assets/javascripts/core.js</h3>
            <hr>
                <div class='func'>
                <b>object WebSync.tmp;</b>
                <br>
                <i>Type: Variable, Line: 14</i>
                <br>
                <span>Provides a location for temporary data to be stored.</span>
                </div>
                <div class='func'>
                <b>boolean WebSync.webSocketFirstTime;</b>
                <br>
                <i>Type: Variable, Line: 17</i>
                <br>
                <span>Websocket first connection?</span>
                </div>
                <div class='func'>
                <b>void WebSync.webSocketStart();</b>
                <br>
                <i>Type: Function, Line: 20</i>
                <br>
                <span>Creates the websocket for communication.</span>
                </div>
                <div class='func'>
                <b>object WebSync.webSocketCallbacks;</b>
                <br>
                <i>Type: Variable, Line: 29</i>
                <br>
                <span>An object with all of the callbacks for a websocket connection.</span>
                </div>
                <div class='func'>
                <b>void WebSync.initialize();</b>
                <br>
                <i>Type: Function, Line: 106</i>
                <br>
                <span>This is where the core of Web-Sync initializes.</span>
                </div>
                <div class='func'>
                <b>string WebSync.viewMode;</b>
                <br>
                <i>Type: Variable, Line: 229</i>
                <br>
                <span>This is the current visual mode. This can be either 'zen' or 'normal'</span>
                </div>
                <div class='func'>
                <b>boolean WebSync.menuVisible;</b>
                <br>
                <i>Type: Variable, Line: 232</i>
                <br>
                <span>This tells you if the menu ribbon is visible or not. In zen mode it can disappear.</span>
                </div>
                <div class='func'>
                <b>void WebSync.updateRibbon();</b>
                <br>
                <i>Type: Function, Line: 311</i>
                <br>
                <span>This updates the ribbon buttons based on the content in the ribbon bar. <span class="todo">TODO:</span> Use registration system & persist menu between updates.</span>
                </div>
                <div class='func'>
                <b>void WebSync.loadScripts();</b>
                <br>
                <i>Type: Function, Line: 327</i>
                <br>
                <span>Checks server for plugin scripts to load.</span>
                </div>
                <div class='func'>
                <b>void WebSync.showHTML();</b>
                <br>
                <i>Type: Function, Line: 332</i>
                <br>
                <span>Converts visible text to HTML. <span class="todo">TODO:</span> Delete/figure something out.</span>
                </div>
                <div class='func'>
                <b>string WebSync.getHTML();</b>
                <br>
                <i>Type: Function, Line: 337</i>
                <br>
                <span>This will return sanitized document HTML. <span class="todo">TODO:</span> This should be migrated into the page handler.</span>
                </div>
                <div class='func'>
                <b>void WebSync.resize();</b>
                <br>
                <i>Type: Function, Line: 345</i>
                <br>
                <span>Event handler for when the window resizes. This is an <span class="internal">internal</span> method.</span>
                </div>
                <div class='func'>
                <b>void WebSync.checkDiff();</b>
                <br>
                <i>Type: Function, Line: 352</i>
                <br>
                <span>This is an <span class="internal">internal</span> method that executes every couple of seconds while the client is connected to the server. It checks to see if there have been any changes to document. If there are any changes it sends a message to a Web Worker to create a patch to transmit.</span>
                </div>
                <div class='func'>
                <b>void WebSync.insertAtCursor(jQuery node);</b>
                <br>
                <i>Type: Function, Line: 371</i>
                <br>
                <span>Inserts a DOM element at selection cursor. This is probably going to be deprecated.</span>
                </div>
                <div class='func'>
                <b>object WebSync.getCss();</b>
                <br>
                <i>Type: Function, Line: 387</i>
                <br>
                <span>Returns the calculated CSS for the current selection. Warning: This can cause the client to run slowly if used too much.</span>
                </div>
                <div class='func'>
                <b>void WebSync.applyCssToSelection(object css);</b>
                <br>
                <i>Type: Function, Line: 395</i>
                <br>
                <span>Applies css to the selection. Uses jQuery css object format. Warning: This is rather slow and shouldn't be overly used.</span>
                </div>
                <div class='func'>
                <b>void WebSync.register(string PluginName, function Plugin);</b>
                <br>
                <i>Type: Function, Line: 401</i>
                <br>
                <span>Registers a plugin with the WebSync core. Plugin.enable() will be called afterwards. Plugin.disable() will be used to disable the plugin.</span>
                </div>
                <div class='func'>
                <b>object WebSync.plugins;</b>
                <br>
                <i>Type: Variable, Line: 409</i>
                <br>
                <span>List of all the plugins loaded in the format of {myawesomeplugin: object Plugin, ...}.</span>
                </div>
                <div class='func'>
                <b>void WebSync.alert(string Message);</b>
                <br>
                <i>Type: Function, Line: 412</i>
                <br>
                <span>Displays an alert message in the lower right hand corner of the window.</span>
                </div>
                <div class='func'>
                <b>void WebSync.error(string Message);</b>
                <br>
                <i>Type: Function, Line: 417</i>
                <br>
                <span>Displays an error message in the lower right hand corner of the window.</span>
                </div>
                <div class='func'>
                <b>void WebSync.success(string Message);</b>
                <br>
                <i>Type: Function, Line: 422</i>
                <br>
                <span>Displays a success message in the lower right hand corner of the window.</span>
                </div>
                <div class='func'>
                <b>void WebSync.info(string Message);</b>
                <br>
                <i>Type: Function, Line: 427</i>
                <br>
                <span>Displays an info message in the lower right hand corner of the window.</span>
                </div>
                <div class='func'>
                <b>void WebSync.alert_msg(string Message, string Classes);</b>
                <br>
                <i>Type: Function, Line: 432</i>
                <br>
                <span>Displays an message in the lower right hand corner of the window with css classes.</span>
                </div>
            <a href="#" onclick="$('#1').toggle(); false"><h4>View Source</h4></a>
            <pre class="script prettyprint" id="1">/*
    Web-Sync: Edit.js
    This is the core file that runs the Web-Sync editor.

    Copyright (c) 2013. All Rights reserved.

    Tristan Rice
    rice (at) outerearth (dot) net
    http://tristanrice.name/
*/

var WebSyncProto = function(){};
WebSyncProto.prototype = {
    // Variable: object WebSync.tmp;
    // Provides a location for temporary data to be stored.
    tmp: {},
    // Variable: boolean WebSync.webSocketFirstTime;
    // Websocket first connection?
	webSocketFirstTime: true,
    // Function: void WebSync.webSocketStart();
    // Creates the websocket for communication.
	webSocketStart: function(){
		WebSync.connection = new WebSocket("ws://"+window.location.host+window.location.pathname);
		WebSync.connection.onopen = WebSync.webSocketCallbacks.onopen;
		WebSync.connection.onclose = WebSync.webSocketCallbacks.onclose;
		WebSync.connection.onmessage = WebSync.webSocketCallbacks.onmessage;
		WebSync.connection.onerror = WebSync.webSocketCallbacks.onerror;
	},
    // Variable: object WebSync.webSocketCallbacks;
    // An object with all of the callbacks for a websocket connection.
	webSocketCallbacks: {
		onopen: function(e){
			console.log(e);
			WebSync.diffInterval = setInterval(WebSync.checkDiff,500);
			$(".navbar-inner").removeClass("no-connection");
			$("#connection_msg").remove();
			if(WebSync.webSocketFirstTime){
				WebSync.webSocketFirstTime = false;
				WebSync.connection.sendJSON({type:'connect'});
				WebSync.loadScripts();
			} else {
				WebSync.connection.sendJSON({type:'reconnect'});
				WebSync.success("&#60;strong&#62Success!&#60;/strong&#62 Connection restablished.");
			}
		},

		onclose: function(e){
			console.log(e);
			if(WebSync.diffInterval){
				clearInterval(WebSync.diffInterval);
				$(".navbar-inner").addClass("no-connection");
				WebSync.error("&#60;strong&#62Connection Lost!&#60;/strong&#62 Server is currently unavailable.").get(0).id="connection_msg";
				WebSync.diffInterval=null;
			}
			setTimeout(WebSync.webSocketStart,2000);
		},
		onmessage: function(e){
			console.log(e);
			data = JSON.parse(e.data);
			console.log("Message data:",data);
			if(data.type=="scripts"){
                // Load scripts from server.
				data.js.forEach(function(script){
					console.log("Loading script:",script);
					$(document.body).append($('&#60;script type="text/javascript" src="'+script+'"&#62&#60;/script&#62'))
				});
			}
            else if(data.type=="text_patch"){
                // Make sure there aren't any outstanding changes that need to be sent before patching document.
                // TODO: Make this work with webworkers
                WebSync.checkDiff();
                // Get start selection.
				var sel = getSelection();
                var range, startText,startOffset,endText,endOffset;
                if(sel.rangeCount&#620){
                    range = sel.getRangeAt(0);
                    startText = range.startContainer.nodeValue;
                    startOffset = range.startOffset;
                    endText = range.endContainer.nodeValue;
                    endOffset = range.endOffset;
                }
                WebSync.tmp.range = {
                    active: (sel.rangeCount&#621),
                    startText: startText,
                    startOffset: startOffset,
                    endText: endText,
                    endOffset: endOffset
                }
                // Patch the HTML.
                var new_html = WebSync.getHTML();
                WebSync.worker.postMessage({cmd:'apply_patch',html:new_html,patch:data.patch});
            }
			else if(data.type=="name_update"){
				$("#name").text(data.name);
			}
			else if(data.type="text_update"){
				$(".content .page").get(0).innerHTML=data.text;
				WebSync.old_html = data.text;
			}
		},
		onerror:function(e){
			console.log(e);
		}

	},
    // Function: void WebSync.initialize();
    // This is where the core of Web-Sync initializes.
	initialize: function(){
		this.webSocketStart();
		$("#name").keyup(function(){
			var div = $("#name").get(0);
			div.innerHTML = div.innerText;
		});
		$("#name").blur(function(){
			$(this).html($(this).text());
			WebSync.connection.sendJSON({type: "name_update", name: $("#name").text()});
		});
		$("#name").focus(function(){
			if(this.innerText=="Unnamed Document"){
                setTimeout(function(){
                    document.execCommand('selectAll');
                },100);
            }
		});
		$(".menu, .content_well").bind("mousedown selectstart",function(e){ if(e.target.tagName!="SELECT"){return false;} });
		$(".content").children().bind("mousedown selectstart",function(e){ e.stopPropagation(); });
		$("#name").bind("mousedown selectstart",function(e){ e.stopPropagation(); });
        $('#zoom_level').change(function(){
			var zoom = parseInt($('#zoom_level').val())/100.0
			$(".content_well").children().animate({"transform":"scale("+zoom+")"});
        });
        $('body').mousemove(function(e){
            if(WebSync.viewMode=='Zen'){
                if(e.pageY&#60;85&&!WebSync.menuVisible){
                    $(".menu").animate({top: 0});
                    WebSync.menuVisible = true;
                }
                else if(e.pageY&#6285&&WebSync.menuVisible) {
                    $(".menu").animate({top: -85});
                    WebSync.menuVisible = false;
                }
            }
        });
        $('#view_mode').change(function(){
            var mode = $('#view_mode').val();
            WebSync.viewMode = mode;
            if(mode=='Zen'){
                $("body").addClass("zen").resize(); $("#zoom_level").val("120%").change(); $(".menu").animate({top:-85});
            }
            else {
                $("body").removeClass("zen").resize(); $("#zoom_level").val("100%").change(); $(".menu").animate({top: 0});
            }
        });
		this.updateRibbon();
		rangy.init();
		console.log(rangy)
		/*
		 * Cursor Blink
		 * For future other people.
		setInterval(function(){
			$("cursor").toggleClass("hidden");
		},1000);
		*/
        $('[data-toggle="tooltip"]').tooltip();
        $('#settingsBtn').click(function(){
			$(this.parentElement).toggleClass("active");
            $(".settings-popup").toggle();
            WebSync.resize();
		});
        $('.settings-popup .close').click(function(){
			$($("#settingsBtn").get(0).parentElement).toggleClass("active");
            $(".settings-popup").toggle();
        });
        this.worker = new Worker("/assets/edit-worker.js");
        this.worker.onmessage = function(e) {
            var data = e.data;
            console.log(data);
            if(data.cmd=='diffed'){
                WebSync.connection.sendJSON({type: "text_patch", patch: data.diff});
            }
            else if(data.cmd=='patched'){
                $(".content .page").get(0).innerHTML=data.html;
                WebSync.old_html = WebSync.getHTML();
                sel = WebSync.tmp.range;
                if(sel.active){
                    // Find all #text nodes.
                    var text_nodes = $(".page").find(":not(iframe)").addBack().contents().filter(function() {
                        return this.nodeType == 3;
                    });
                    var startText = range.startText, startOffset = range.startOffset, endText = range.endText, endOffset = range.endOffset;
                    var startNode = {};
                    var endNode = {};
                    console.log(text_nodes);
                    var startNodeDist = 99999;
                    var endNodeDist = 99999;
                    // Locate the start & end #text nodes based on a Levenstein string distance.
                    text_nodes.each(function(index, node){
                        var dist = levenshteinenator(node.nodeValue,startText);
                        if(dist&#60;startNodeDist){
                            startNode = node;
                            startNodeDist = dist;
                        }
                        dist = levenshteinenator(node.nodeValue,endText);
                        if(dist&#60;endNodeDist){
                            endNode = node;
                            endNodeDist = dist;
                        }
                    });
                    // Update the text range.
                    var range = document.createRange();
                    range.setStart(startNode,startOffset);
                    range.setEnd(endNode,endOffset);
                    window.getSelection().removeAllRanges();
                    window.getSelection().addRange(range);
                }
                // Prevent checkDiff() from sending updates for patches.
            }
            else if(data.cmd=='log'){
                console.log(data.msg);
            }
         }
		this.applier = rangy.createCssClassApplier("tmp");
		// TODO: Better polyfil for firefox not recognizing -moz-user-modify: read-write
        $(".page").attr("contenteditable","true");
        this.resize();
        $(window).resize(this.resize);
        //this.setupWebRTC();
	},
    // Variable: string WebSync.viewMode;
    // This is the current visual mode. This can be either 'zen' or 'normal'
    viewMode: 'normal',
    // Variable: boolean WebSync.menuVisible;
    // This tells you if the menu ribbon is visible or not. In zen mode it can disappear.
    menuVisible: true,
    // WARNING: Experimental & Unsupported in many browsers!
	// WebRTC Peer functionality. This will be used for communication between Clients. Video + Text chat hopefully.
	setupWebRTC: function(){
		if(WebSync.createPeerConnection()){
		    WebSync.createDataChannel();
        }
	},
	createPeerConnection: function() {
		var pc_config = {"iceServers": [{"url": "stun:stun.l.google.com:19302"}]};
		var pc_constraints = {"optional": [{"RtpDataChannels": true}]};
		// Force the use of a number IP STUN server for Firefox.
		if (webrtcDetectedBrowser == "firefox") {
			pc_config = {"iceServers":[{"url":"stun:23.21.150.121"}]};
		}
		try {
		// Create an RTCPeerConnection via the polyfill (adapter.js).
		WebSync.pc = new RTCPeerConnection(pc_config, pc_constraints);
		WebSync.pc.onicecandidate = WebSync.onIceCandidate;
		console.log("Created RTCPeerConnnection with:\n" +
			  "  config: \"" + JSON.stringify(pc_config) + "\";\n" +
			  "  constraints: \"" + JSON.stringify(pc_constraints) + "\".");
		} catch (e) {
			console.log("Failed to create PeerConnection, exception: " + e.message);
			alert("Cannot create RTCPeerConnection object; WebRTC is not supported by this browser.");
			return false;
		}

		WebSync.pc.onaddstream = WebSync.onRemoteStreamAdded;
		WebSync.pc.onremovestream = WebSync.onRemoteStreamRemoved;
		WebSync.pc.ondatachannel = WebSync.onDataChannel;
        return true;
	},
	createDataChannel: function() {
		WebSync.dataChannel = WebSync.pc.createDataChannel("chat",{reliable:false});
		WebSync.dataChannel.onopen = WebSync.reportEvent;
		WebSync.dataChannel.onclose = WebSync.reportEvent;
		WebSync.dataChannel.onerror = WebSync.reportEvent;
		WebSync.dataChannel.onmessage = WebSync.reportEvent;
	},
	setupPeerOffer: function(isCaller){
		if (isCaller)
		    WebSync.pc.createOffer(gotDescription);
		else
		    WebSync.pc.createAnswer(WebSync.pc.remoteDescription, gotDescription);

		function gotDescription(desc) {
		    pc.setLocalDescription(desc);
		    signalingChannel.send(JSON.stringify({ "sdp": desc }));
		}
	},
	reportEvent: function(event) {
		console.log(event);
	},
	onIceCanidate: function onIceCandidate(event) {
		if (event.candidate) {
		sendMessage({type: 'candidate',
			   label: event.candidate.sdpMLineIndex,
			   id: event.candidate.sdpMid,
			   candidate: event.candidate.candidate});
		} else {
		console.log("End of candidates.");
		}
	},
	onRemoteStreamAdded: function onRemoteStreamAdded(event) {
		console.log("Remote stream added.");
		reattachMediaStream(miniVideo, localVideo);
		attachMediaStream(remoteVideo, event.stream);
		remoteStream = event.stream;
		waitForRemoteVideo();
	},
	onRemoteStreamRemoved: function onRemoteStreamRemoved(event) {
		console.log("Remote stream removed.");
	},
	onDataChannel: function(event){
		console.log("Data Channel:",event);
	},
    // Function: void WebSync.updateRibbon();
    // This updates the ribbon buttons based on the content in the ribbon bar. TODO: Use registration system & persist menu between updates.
	updateRibbon: function(){
		var menu_buttons = "";
		$(".ribbon .container").each(function(elem){
			menu_buttons += '&#60;li&#62&#60;a&#62'+this.id+'&#60;/a&#62&#60;/li&#62'
		});
		$('#ribbon_buttons').html(menu_buttons);
		$('#ribbon_buttons li').click(function(e){
			$('#ribbon_buttons li').removeClass('active');
			$(this).addClass('active');
			$('.ribbon .container').hide();
			$("#"+$(this).text()).show();
		});
		$($('#ribbon_buttons li').get(2)).click();
	},
    // Function: void WebSync.loadScripts();
    // Checks server for plugin scripts to load.
	loadScripts: function(){
		WebSync.connection.sendJSON({type: "load_scripts"});
	},
    // Function: void WebSync.showHTML();
    // Converts visible text to HTML. TODO: Delete/figure something out.
	showHTML: function(){
		$('.page').html("&#60;code&#62"+WebSync.getHTML()+"&#60;/code&#62");
	},
    // Function: string WebSync.getHTML();
    // This will return sanitized document HTML. TODO: This should be migrated into the page handler.
	getHTML: function(){
		var html = $(".page").html().trim();
		// Remove other cursors.
		html = html.replace(/\&#60;cursor[^\/]+\/?\&#60;\/cursor\&#62/g,"")
		return html;
	},
    // Function: void WebSync.resize();
    // Event handler for when the window resizes. This is an internal method.
    resize: function(){
        $(".content_well").height(window.innerHeight-$(".content_well").position().top)
        $(".settings-popup").css({left:(window.innerWidth-944)*0.5})
        $(".arrow").offset({left:$("#settingsBtn").offset().left+16})
    },
    // Function: void WebSync.checkDiff();
    // This is an internal method that executes every couple of seconds while the client is connected to the server. It checks to see if there have been any changes to document. If there are any changes it sends a message to a Web Worker to create a patch to transmit.
	checkDiff: function(){
		var new_html = WebSync.getHTML();
		if(typeof WebSync.old_html == "undefined"){
			WebSync.old_html = new_html;
		}
		if(new_html!=WebSync.old_html){
			if(WebSync.old_html==""){
				WebSync.connection.sendJSON({type: "text_update",text: new_html})
			}
			else {
                // Send it to the worker thread for processing.
                var msg = {'cmd':'diff','oldHtml':WebSync.old_html,'newHtml':new_html};
                WebSync.worker.postMessage(msg);
			}
			WebSync.old_html=new_html;
		}
	},
    // Function: void WebSync.insertAtCursor(jQuery node);
    // Inserts a DOM element at selection cursor. This is probably going to be deprecated.
	insertAtCursor: function(node) {
		node = node.get(0);
		var sel, range, html;
		if (window.getSelection) {
			sel = window.getSelection();
			if (sel.getRangeAt && sel.rangeCount) {
				range = sel.getRangeAt(0);
				range.deleteContents();
				range.insertNode( node );
			}
		} else if (document.selection && document.selection.createRange) {
			document.selection.createRange().html = node;
		}
	},
    // Function: object WebSync.getCss();
    // Returns the calculated CSS for the current selection. Warning: This can cause the client to run slowly if used too much.
	getCss: function(){
		/*WebSync.applier.toggleSelection();
		if($(".tmp").length==0) return {};
		return $(".tmp").removeClass("tmp").getStyleObject();*/
		return $(getSelection().baseNode.parentNode).getStyleObject();
	},
    // Function: void WebSync.applyCssToSelection(object css);
	// Applies css to the selection. Uses jQuery css object format. Warning: This is rather slow and shouldn't be overly used.
	applyCssToSelection: function(css){
		WebSync.applier.toggleSelection();
		$(".tmp").css(css).removeClass("tmp");
	},
    // Function: void WebSync.register(string PluginName, function Plugin);
	// Registers a plugin with the WebSync core. Plugin.enable() will be called afterwards. Plugin.disable() will be used to disable the plugin.
    register: function(pluginname, plugin){
		plugin = new plugin();
		console.log("Loading plugin:",pluginname);
		WebSync.plugins[pluginname]=plugin;
		WebSync.plugins[pluginname].enable();
	},
    // Variable: object WebSync.plugins;
    // List of all the plugins loaded in the format of {myawesomeplugin: object Plugin, ...}.
	plugins: {},
    // Function: void WebSync.alert(string Message);
    // Displays an alert message in the lower right hand corner of the window.
	alert: function(msg){
		return WebSync.alert_msg(msg,"");
	},
    // Function: void WebSync.error(string Message);
    // Displays an error message in the lower right hand corner of the window.
	error: function(msg){
		return WebSync.alert_msg(msg,"alert-error");
	},
    // Function: void WebSync.success(string Message);
    // Displays a success message in the lower right hand corner of the window.
	success: function(msg){
		return WebSync.alert_msg(msg,"alert-success");
	},
    // Function: void WebSync.info(string Message);
    // Displays an info message in the lower right hand corner of the window.
	info: function(msg){
		return WebSync.alert_msg(msg,"alert-info");
	},
    // Function: void WebSync.alert_msg(string Message, string Classes);
    // Displays an message in the lower right hand corner of the window with css classes.
	alert_msg: function(msg,classes){
		var div = $('&#60;div class="alert '+classes+'"&#62&#60;a class="close" data-dismiss="alert"&#62&times;&#60;/a&#62'+msg+'&#60;/div&#62');
		$('#alert_well').prepend(div);
		setTimeout(function(){
			div.alert('close');
		},10000);
		return div;
	}
}

WebSocket.prototype.sendJSON = function(object){
	this.send(JSON.stringify(object));
}
function capitaliseFirstLetter(string)
{
    return string.charAt(0).toUpperCase() + string.slice(1);
}

window.WebSync=new WebSyncProto();
WebSync.initialize();</pre>
            <h3>File: assets/javascripts/edit.js</h3>
            <hr>
                <div class='func'>
                <b>void [plugin=TextEdit].fontsInit();</b>
                <br>
                <i>Type: Function, Line: 84</i>
                <br>
                <span>Sets up the list of fonts</span>
                </div>
            <a href="#" onclick="$('#2').toggle(); false"><h4>View Source</h4></a>
            <pre class="script prettyprint" id="2">// Web-Sync: Text Editing Plugin
WebSync.register("TextEdit",function(){ var self = this;
	// Enable: This is where everything should be setup.
	// Plugins should use a jQuery namespace for ease of use.
	// Bind Example: $(document).bind("click.Tables", clickHandler);
	// Unbind Example: $("*").unbind(".Tables");
	this.enable = function(){
        self.text_buttons= ["bold",'italic','strikethrough','underline','justifyleft','justifycenter','justifyright','justifyfull',"removeFormat","insertorderedlist","insertunorderedlist"];
        // Add ribbon text
        $(".ribbon").append('&#60;div id="Text" class="container"&#62 \
				&#60;button id="bold" title="Bold" class="btn"&#62&#60;i class="icon-bold"&#62&#60;/i&#62&#60;/button&#62 \
				&#60;button id="italic" title="Italic" class="btn"&#62&#60;i class="icon-italic"&#62&#60;/i&#62&#60;/button&#62 \
				&#60;button id="strikethrough" title="Strikethrough" class="btn"&#62&#60;i class="icon-strikethrough"&#62&#60;/i&#62&#60;/button&#62 \
				&#60;button id="underline" title="Underline" class="btn"&#62&#60;i class="icon-underline"&#62&#60;/i&#62&#60;/button&#62 \
				&#60;select id="font" title="Font" class="ribbon_button"&#62 \
				&#60;/select&#62 \
				&#60;select id="font_size" title="Font Size" class="ribbon_button"&#62 \
					&#60;option&#628pt&#60;/option&#62 \
					&#60;option&#6210pt&#60;/option&#62 \
					&#60;option&#6211pt&#60;/option&#62 \
					&#60;option&#6212pt&#60;/option&#62 \
					&#60;option&#6214pt&#60;/option&#62 \
					&#60;option&#6224pt&#60;/option&#62 \
					&#60;option&#6236pt&#60;/option&#62 \
				&#60;/select&#62 \
				&#60;div class="btn-group"&#62 \
					&#60;button id="justifyleft" title="Justify Left" class="btn"&#62&#60;i class="icon-align-left"&#62&#60;/i&#62&#60;/button&#62 \
					&#60;button id="justifycenter" title="Justify Center" class="btn"&#62&#60;i class="icon-align-center"&#62&#60;/i&#62&#60;/button&#62 \
					&#60;button id="justifyright" title="Justify Right" class="btn"&#62&#60;i class="icon-align-right"&#62&#60;/i&#62&#60;/button&#62 \
					&#60;button id="justifyfull" title="Justify Full" class="btn"&#62&#60;i class="icon-align-justify"&#62&#60;/i&#62&#60;/button&#62 \
				&#60;/div&#62 \
				&#60;button id="insertunorderedlist" title="Unordered List" class="btn"&#62&#60;i class="icon-list-ul"&#62&#60;/i&#62&#60;/button&#62 \
				&#60;button id="insertorderedlist" title="Ordered List" class="btn"&#62&#60;i class="icon-list-ol"&#62&#60;/i&#62&#60;/button&#62 \
				&#60;button id="removeFormat" title="Clear Formatting" class="btn"&#62&#60;i class="icon-remove"&#62&#60;/i&#62&#60;/button&#62 \
			&#60;/div&#62');
        self.text_buttons.forEach(function(elem){
			$('button#'+elem).bind("click.TextEdit",function(){
				document.execCommand(elem);
				//$(this).toggleClass("active");
				$(document).trigger('selectionchange');
			});
		});
        // Setup font list.
        self.fontsInit();
        // Reflects text in menu at top
		$(document).bind('selectionchange.TextEdit',function(){
			if(!self._selectTimeout){
				self._selectTimeout = setTimeout(self.selectHandler,200);
			}
		});
		$('#font').bind("change.TextEdit",function(){
			document.execCommand('fontname',false,$('#font').val());
		});
		$('#font_size').change(function(){
			var size = $('#font_size').val()
			console.log(size);
			WebSync.applyCssToSelection({'font-size':size});
		});
    }
    this.disable = function(){
		var elem = $("#Text").remove();
		WebSync.updateRibbon();
		$("*").unbind(".TextEdit");
		$("*").undelegate(".TextEdit");
    }
    // Handling function for displaying accurate information about text in ribbon.
    this.selectHandler = function(){
		var style = WebSync.getCss();
		$('#font_size').val(Math.round(parseInt(style.fontSize)*(0.75))+"pt");

		self.text_buttons.forEach(function(elem){
			var button = $('button#'+elem)
			if(document.queryCommandState(elem)){
				button.addClass("active");
			}
			else {
				button.removeClass('active');
			}
		});
		$('#font').val(capitaliseFirstLetter(document.queryCommandValue('fontname').split("'").join("")));
		clearTimeout(self._selectTimeout);
		self._selectTimeout = null;
	}
    // Function: void [plugin=TextEdit].fontsInit();
    // Sets up the list of fonts
	this.fontsInit = function(){
		var fonts = ["Cursive","Monospace","Serif","Sans-serif","Fantasy","Arial","Arial Black","Arial Narrow","Arial Rounded MT Bold","Bookman Old Style","Bradley Hand ITC","Century","Century Gothic","Comic Sans MS","Droid Sans","Courier","Courier New","Georgia","Gentium","Impact","King","Lucida Console","Lalit","Modena","Monotype Corsiva","Papyrus","TeX","Times","Times New Roman","Trebuchet MS","Tahoma","Verdana","Verona",'Helvetica','Segoe'];
    	var d = new Detector();
		var font_list = [];
	    fonts = fonts.sort(function(a,b){
			if(a&#60;b) return -1;
			if(a&#62b) return 1;
			return 0;
		});
		for (i = 0; i &#60; fonts.length; i++) {
		    var result = d.detect(fonts[i]);
			if(result){
				font_list.push("&#60;option&#62"+fonts[i]+"&#60;/option&#62");
			}
	    }
		$('#font').html(font_list.join("\n"));
   	}

});</pre>
        <script type='text/javascript'>
            $("a").click(function(e){
                e.preventDefault();
            });
        </script>
    </body>
</html>
